How generator functions are used for PyTest fixtures
====================================================
:author:    Jan-Hein BÃ¼hrman (happily using asciidoc w/ slidy backend)
:copyright: Ordina
:backend:   slidy
:max-width: 47em
:data-uri:
:icons:

// .Contents
// [role="incremental"]
// * Learning objectives
// * A basic PyTest fixture
// * Context Switch: _generator functions_ session
// * _iterator protocol_ session
// * Using fixtures to clean up stuff after test execution in PyTest
// * Example (if time permits): temporarily manipulate environment
// * Concluding remarks
// * Recap


What you will know in 15 minutes from now
-----------------------------------------
[role="incremental"]
* What a fixture is
* How to make a basic PyTest fixture
* What a _generator function_ is
* What the _iterator protocol_ is
* What test "set-up" and "tear-down" functionality is used for
* How to make a PyTest fixture with "set-up" and "tear-down" functionality


A basic PyTest fixture
----------------------
[role="incremental"]
* A _fixture_ is used to arrange something that the _code under test_ needs so the test can be run.
* It can be some constructed _data_, or a _resource_.
* Usually, you create a fixture when you need the same thing to be done in _multiple tests_
** [DRY -- Don't Repeat Yourself]
* In PyTest, a you can _create_ a fixture by decorating a function with `@pytest.fixture`
+
[source,python]
---------------------------------------------------------------------
@pytest.fixture
def some_fixture():
    return "something"
---------------------------------------------------------------------
* A PyTest-based test function can _use_ a fixture by just _declaring it as a parameter_
+
[source,python]
---------------------------------------------------------------------
def test_function(some_fixture):
    assert some_fixture == "something"
---------------------------------------------------------------------
* So what's happening here?
** The `test_function` requests `some_fixture` by declaring it as an parameter,
** `some_fixture` is called (under the hood) by `pytest`, and
** whatever it returns is passed as an _argument_ to the requesting `test_function`.


Demo: `test_basic_fixture`
--------------------------
//


Context Switch: Generator Functions
-----------------------------------
What is a _generator function_?

[role="incremental"]
* A _generator function_, when called, returns a _generator iterator_,
* This _iterator_ can subsequently be used in a `for` loop, for example.
* Each time you requests an item from it, the generator
[role="incremental"]
** gives back the item,
** saves it state, and
** passes control back to the calling code.

[role="incremental"]
How does it work?

[role="incremental"]
* A _plain_ function becomes a _generator_ function when it contains one or more `yield` statements
* In each iteration, the _generator_ runs until the `yield` statement
* The value of the `yield` statement is returned back to the caller
* If there are no more `yield` statements to execute, the function runs until the end or a `return` statement, signalling the end


Demo: `demo_generator_function`
-------------------------------
* This demo shows how _generator functions_ are created and being used
+
.Demo time
---


Iterator Protocol
-----------------
[role="incremental"]
* When Python executes a `for` loop, it executes the _iterator protocol_
* For example, the following `for` loop: ...
+
[source,python]
---------------------------------------------------------------------
for i in range(3):
    print(i)
---------------------------------------------------------------------
* ... executes (under the hood) as: ...
+
[source,python]
---------------------------------------------------------------------
it = iter(range(3))  # `it` is an _iterator_, `range()` an _iterable_
while True:
    try:
        i = next(it)
    except StopIteration:
        break
    print(i)
---------------------------------------------------------------------
* First, an _iterator_ is created from an _iterable_, by calling `iter()`,
* then each time, a new item from the _iterator_ is requested by `next()`,
* when the iterator is exhausted, `StopIteration` is raised.


Demo: `demo_iterator_protocol`
------------------------------
[role="incremental"]
* This demo shows the _iterator protocol_
* It also shows *what* part of a _generator iterator_ is executed *when*
+
.Demo time
---


Using fixtures to clean up stuff after test execution in PyTest
---------------------------------------------------------------
[role="incremental"]
Frequently, _fixtures_ *allocate* resources that need to be *cleaned up* after use

[role="incremental"]
* Python `unittest.TestCase` uses `.setUp()` and `.tearDown()` to this purpose

[role="incremental"]
How is the "set-up" and "tear-down" functionality achieved in PyTest based tests?
[role="incremental"]
* By providing a _generator function_ as fixture.
* Instead of using `return` to pass back whatever you want to provide,
* use (one single) `yield` to pass back whatever you want to provide.
* Whatever you code _before_ the `yield` statement, can be regarded as the "set-up" part, and
* whatever you code _after_ the `yield` statement, is the "tear-down" part.
[role="incremental"]
[source,python]
---------------------------------------------------------------------
@pytest.fixture
def another_fixture():
    # DO SETUP STUFF HERE
    yield "whatever you would like to provide"
    # DO TEARDOWN STUFF HERE
---------------------------------------------------------------------

[role="incremental"]
NOTE: The "tear-down" part is protected against possible exceptions that might occur during execution of the test function.


Demo: `test_fixture_with_cleanup`
---------------------------------
//


Some final notes
----------------
[role="incremental"]
If you _only_ need the _side effects_ of the fixture, but _not_ it's returned or yielded value,

[role="incremental"]
* decorate your test function with `@pytest.mark.usefixtures("fixture_name")`,
* instead of declaring the fixture as a _parameter_.

[role="incremental"]
NOTE: The "tear-down" part is _not_ protected against possible exceptions during set-up execution.

[role="incremental"]
The `@contextlib.contextmanager` decorator applies the same trick to a _generator function_, to split the functionality in an "enter" part and an "exit" part.

[role="incremental"]
* You can use the resulting object in a Python `with` statement
* If you want to ensure that the "exit" part of your context manager is run, regardless of any exceptions occurring in the body of the `with` statement,
** protect it with a `try: ... finally:`, as in:
[role="incremental"]
[source,python]
---------------------------------------------------------------------
@contextlib.contextmanager
def another_fixture():
    # DO ENTER STUFF HERE
    try:
        yield "whatever you would like to provide"
    finally:
        # DO EXIT STUFF HERE
---------------------------------------------------------------------


Recap
-----
You've heard about the following:
[role="incremental"]
* What a fixture is
* How to make a basic PyTest fixture
* What a _generator function_ is
* What the _iterator protocol_ is
* What test "set-up" and "tear-down" functionality is used for
* How to make a PyTest fixture with "set-up" and "tear-down" functionality

[role="incremental"]
.Questions
*********************************************************************
?                                 ?                                 ?
*********************************************************************
