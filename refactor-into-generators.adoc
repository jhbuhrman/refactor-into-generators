= When To Refactor Into Generators And How
:author:    Jan-Hein Bührman
:email:     {lt}jan-hein.buhrman@ordina.nl{gt}
// :backend:   slidy
//:backend: revealjs
//:stem:
:max-width: 80em
:twitter-tag: @jbuhrman
:conference-tag: @FIXME
:data-uri:
:icons: font
:sourcedir: .
// beige, black, league, night, serif, simple, sky, solarized, white
:revealjs_theme: beige
// "moon" is an alternative if you don't get the syntax highlighting
// in a light theme
// 25 mins
:revealjs_totalTime: 1500
:revealjs_controlsTutorial: false
:revealjs_hash: true
:source-highlighter: highlightjs
:highlightjs-languages: gherkin,pycon
//:source-highlighter: pygments
//:highlightjs-theme: a11y-light
//:pygments-linenums-mode: inline

include::revealjs_settings.adoc[]



== Goals

After this presentation, you will ...

// [role="incremental"]

* be able to _recognize_ certain loop constructs as candidate for
  refactoring,
* know _how_ to convert these constructs into more maintainable
  _Pythonic_ code,
+
by refactoring them into an elegant pipeline of generators.
* be more acquainted with the standard library `itertools` module and
  the `more-itertools` package

// FIXME: shorter sentences on slide - put full text in notes
// FIXME: perhaps add something about TDD/Gherkin


== Topics

// [role="incremental"]

* Loops with similar code but with varying start/stop/selection
  criteria
* What is refactoring
* Short intro on a Generator function
* How to recognize some "patterns" of loop constructs as refactoring
  candidates
* FIXME: what else? Add later


== Variations on Fibonacci Number Selections

.**(a fictional story)**

// [role="incremental"]

* Suppose your Product Owner requires a function that returns a list of
  all Fibonacci number less than _n_
* Who knows what a Fibonacci number is? ✋

== Fibonacci Number (definition)

[quote, Wikipedia, "Fibonacci number"]
--
In mathematics, the **Fibonacci numbers** [...] form a sequence, the
**Fibonacci sequence**, in which each number is the sum of the two
preceding ones. The sequence commonly starts from 0 and 1, [...]

Starting from 0 and 1, the next few values in the sequence are:

{empty}:: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
--



== First N Fibonacci Numbers in Gherkin

[source,gherkin]
--
include::{sourcedir}/tests/features/fib_list_to.feature[lines="2.."]
--

// FIXME FIXME: perhaps the persona should be "Fibonaccista" ?

// FIXME - add a new slide here? (prevent information overflow?)
//   If yes, just repeat the GIVEN - WHEN - THEN clauses of the previous

//[role="incremental"]
//* There are many people advocating to put in-line parameters (like
//  `"10"`) between double quotes. That doesn't mean that it should be
//  seen a string of some sort, but rather as a clear indication that it
//  is a parameter.

// FIXME: also mention that Gherkin is mostly used for "business"
//   functionality (check this out on Automation Panda), but I think
//   it can be helpful for "lower level" functions as well, making it a
//   clear specification.


//[role="incremental"]
//[horizontal]
//**Given**:: Describes a stable, intial state of the system _before_ the relevant action is taken
//**When**:: Describes the _action_ that is relevant for this specific scenario
//**Then**:: Describes the _outcome_ of the action

//[role="incremental"]
//* Credits:
//  https://automationpanda.com/2017/01/26/bdd-101-the-gherkin-language
// (credits & more info: https://automationpanda.com/2017/01/26/bdd-101-the-gherkin-language/[Automation Panda])

// FIXME: Mention Pandy Knight, the owner of the Automation Panda site,
//   who has given various presentations about Python and testing


//== Implementation
// // Highlight doesn't work (yet); perhaps CSS required?? [source,python,highlight=2..5]
//[role="incremental"]
//[source,python,highlight="4,7"]
//----
//include::{sourcedir}/src/fibonacci/typeless.py[]
//----
//
//[role="incremental"]
//* Source: https://docs.python.org/3/tutorial/modules.html
//* ❓ Shall we add type annotations ❓


== Fibs Less Than N (Python)

[source,python]
--
include::{sourcedir}/src/fibonacci/before.py[lines="1..8"]
--
* Source: https://docs.python.org/3/tutorial/modules.html

== Product Owner is happy and wants more

* Happy with the delivered result, the Product Owner asks for more
  functionality:

// FIXME: perhaps change the word "excited" to something else?
// [role="incremental"]
--
[quote, Happy Product Owner, More Features]
____________________________________________________________________
Can you also make a function that returns the _n_'th Fibonacci number
(counting from zero)?
____________________________________________________________________
--


=== Add Gherkin for the N'th Fibonacci number

[source,gherkin]
--
include::{sourcedir}/tests/features/fib_ordinal.feature[lines="2.."]
--


== Python source for the N'th Fibonacci number

[source,python]
--
include::{sourcedir}/src/fibonacci/before.py[lines="11..18"]
--


== Now the Product Owner really gets enthusiastic!

[quote, Very Enthusiastic Product Owner, Even More features]
--
Now that we've got functions for ...

* Fibonacci numbers up to N,
* the N'th Fibonacci number,
+
..., can you also make functions that return ...
+
* the first N Fibonacci numbers,
* the largest Fibonacci number less than N, and
* the smallest Fibonacci number greater than or equal to N?
--


=== The First N Fibs (Gherkin)

[soure,gherkin]
----
include::{sourcedir}/tests/features/first_n_fibs.feature[]
----


== The First N Fibs (Python)

[source,python]
--
include::{sourcedir}/src/fibonacci/before.py[lines="21..30"]
--


=== Largest Fib Less Than N (Gherkin)

[soure,gherkin]
--
include::{sourcedir}/tests/features/largest_fib_less_than.feature[]
--


== The Largest Fib Less Than N (Python)

[source,python]
--
include::{sourcedir}/src/fibonacci/before.py[lines="33..40"]
--


=== Smallest Fib Greater/Equal N (Gherkin)

[soure,gherkin]
--
include::{sourcedir}/tests/features/smallest_fib_greater_equal.feature[]
--


== Smallest Fib Greater/Equal N (Python)

[source,python]
--
include::{sourcedir}/src/fibonacci/before.py[lines="43..48"]
--


// FIXME: THIS IN ALTERNATIVE WAY OF PRESENTING LAST 3 FIBS
//== As requested, implemented (condensed)
//[source,python]
//----
//include::{sourcedir}/src/fibonacci/before_compressed.py[lines="42..49"]
//include::{sourcedir}/src/fibonacci/before_compressed.py[lines="52..57"]
//include::{sourcedir}/src/fibonacci/before_compressed.py[lines="59..64"]
//----


== All (shortened) function bodies next to each other

[cols=2*]
|===
a|[source,python]
include::{sourcedir}/src/fibonacci/before_compressed.py[lines="25..30"]
a|[source,python]
include::{sourcedir}/src/fibonacci/before_compressed.py[lines="43..48"]

a|[source,python]
include::{sourcedir}/src/fibonacci/before_compressed.py[lines="35..38"]
a|[source,python]
include::{sourcedir}/src/fibonacci/before_compressed.py[lines="53..56"]

|Do you see a pattern? ✋
a|[source,python]
include::{sourcedir}/src/fibonacci/before_compressed.py[lines="60..63"]
|===


[.notes]
--
[cols=2*]
|===
|fib_list_to
|first_n_fibs

|fib_ordinal
|largest_fib_less_than

|{empty}
|smallest_fib_greater_equal

|===

* We're seeing a pattern here, don't we?
--


== The pattern

[source,python]
--
def some_fib_related_func(some_parameter):
    # (SOMETIMES: INITIALIZE THE LIST)
    a, b = 0, 1  # <1>
    while "some condition or otherwise a for-loop":  # <2>
        # (SOMETIMES: APPEND SOMETHING TO THE LIST)
        a, b = b, a + b  # <3>
    return a  # (OR SOMETIMES: RETURN THE LIST) <4>
--
<1> The variables `a` and `b` are initialized to their initial values
<2> Some `while` or `for` loop is set up
<3> The variables `a` and `b` are assigned their new respective values
<4> The desired calculated value, or a list of these values, is returned

// FIXME: move this terminology to the beginning, where I explain the first fib func
//<1> The two Fibonacci "accumulators" are initialized
//<2> Some loop with some condition is set up
//<3> The two Fibonacci "accumulators" get their respective new values


[.notes]
--
* Now that you've seen this pattern, you start looking for ways to get rid of the apparent _redundancy_ of code.
--



== Time to Start Refactoring Your Code

**(because you don't like redundant code)**

❓ Refactoring ✋


[.notes]
--
* I don't know how you experience it, but I always get this itchy
  feeling if I see repetitions of code
* and I start looking for ways how to refactor the code, extracting the common part into a function or method +
  {nbsp}
* ✋ So who knows what refactoring is?
--

== Refactoring

[quote, Wikipedia, "Code refactoring"]
--
In computer programming and software design, **code refactoring** is the
process of restructuring existing computer code [...] without changing
its external behavior.

Refactoring is intended to improve the design, structure, and/or
implementation of the software (its non-functional attributes), while
preserving its functionality.

Potential advantages of refactoring may include improved code
readability and reduced complexity; these can improve the source code's
maintainability and create a simpler, cleaner, or more expressive
internal architecture or object model to improve extensibility. [...]
--

== Extracting Common Parts Not Doable?

It seems impossible to extract common parts of the code into functions

It is mixed up with control flow constructs -- `while` or `for` loops

Perhaps combine the requested functions ("mode" flags or an enum) ❓


== Experiment: Combine The First Two Functions


WARNING: Put on your Peril-Sensitive Sunglasses{empty}footnote:[https://hitchhikers.fandom.com/wiki/Joo_Janta_200_Super-Chromatic_Peril_Sensitive_Sunglasses]


[source,python]
--
include::{sourcedir}/src/fibonacci/first_two_combined.py[lines="5..18"]
--

[.notes]
--
* Warning: what you see here, really hurts the eye; It starts already with the ugly type annotation, and as the author of `Black`, Łukasz Langa, recently stated in a talk: "ugly type annotations are an indication of ugly code"
* So don't take this contrived example too seriously; it just demonstrates that the resulting code isn't quite _maintable_ and this isn't the way to go
--


== Refactoring The Right Way: Single Responsibility

//It's all about separation of concerns

* The _common_ part between all functions:
** producing Fibonacci numbers
* The _mutually differing_ parts between all functions:
** loop construct:
*** either a `for` loop (counting), or
*** a `while` loop (varying end-conditions)
** how to further process the generated Fibonacci numbers:
*** collected in a list, or
*** just the last calculated "current" Fibonacci number

**how to separate the _common_ part from the _mutually differing_ parts?**

[.notes]
--
* You have to realize that there is a _data producing_ part in your code.
* And _that's_ the part that you can isolate.
--


== Isolate the Data Producing Part into a Generator

[quote,"Python documentation, glossary","\"generator\" and \"generator iterator\" (excerpts)"]
--
[A generator is] a function which returns a _generator iterator_. It looks like a normal
function except that it contains `yield` expressions for producing a
series of values usable in a `for` loop or that can be retrieved one at a
time with the `next()` function.

Each `yield` temporarily suspends processing, remembering the location execution state (including local variables and pending `try` statements). When the generator iterator resumes, it picks up where it left off (in contrast to functions which start fresh on every invocation).
--

== The Fibonacci Number Generator

[source,python]
--
include::{sourcedir}/src/fibonacci/refactored.py[lines="7..12"]
--


[.notes]
--
* So this is how the Fibonacci Number Generator looks like
* [shortly explain the code of `fib_gen()`]
* What you see here, is in essence the "canonical" code representation of the Fibonacci sequence.
--

== Example usage of the Fibonacci generator

Create a list of the first 10 Fibonacci numbers using `fib_gen`: +
{nbsp}

[source,pycon]
--
>>> [fib for _, fib in zip(range(10), fib_gen())]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
--
{nbsp} +
{nbsp} +

Now the requested Fibonacci functions can be refactored, making use of the Fibonacci number generator.

[.notes]
--
* Making the 5 Fibonacci functions (as was requested by the Product
  Owner), making use of `fib_gen` has now become relatively easy.
* But we can go even one step further ...
* [next slide]
--


== Are We Set? Problem Solved?

The next step: make use of the building blocks provided by:

* `itertools`{empty}footnote:[https://docs.python.org/3/library/itertools.html] from the standard library, and
* the `more-itertools`{empty}footnote:[https://more-itertools.readthedocs.io/] external package.

[quote,"Python documentation, library","itertools"]
The [`itertools`] module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an “iterator algebra” making it possible to construct specialized tools succinctly and efficiently in pure Python.

[.notes]
--
* ... because Python's standard library provides a wonderful module
  delivering this functionality without needing to code any loop
  constructs yourself, the `itertools` module [read out the quote]
* what is called the "iterator algebra", is what I would call "a pipeline of iterators"
* *`more-itertools` implements the recipes listed in the `itertools` documentation and provides additional building blocks*.
--


== Fibs Less Than N (Python, Refactored)

[source,python]
--
include::{sourcedir}/src/fibonacci/refactored.py[lines="15..17"]
--
{nbsp} +
[.text-left]
--
``itertools.``**`takewhile`**``(``__``predicate``__``, ``__``iterable``__``)``:

{empty}:: Make an iterator that returns elements from the iterable as long as the predicate is true.
--

[.notes]
--
* You use the `takewhile` "filter" to let pass all the elements until a the condition, coded in the lambda expression returns false.
* Subsequently, you collect the resulting truncated Fibonacci sequence in a list.
--


== The First N Fibs (Python, Refactored)



[source,python]
--
include::{sourcedir}/src/fibonacci/refactored.py[lines="15..17"]
--
{nbsp} +
[.text-left]
--
``itertools.``**`takewhile`**``(``__``predicate``__``, ``__``iterable``__``)``:

{empty}:: Make an iterator that returns elements from the iterable as long as the predicate is true.
--

[.notes]
--
* You use the `takewhile` "filter" to let pass all the elements until a the condition, coded in the lambda expression returns false.
* Subsequently, you collect the resulting truncated Fibonacci sequence in a list.
--

== FIXME CURRENT END OF PRESENTATION

//== Test
//[role="incremental"]
//[horizontal]
//CPU:: Central Processing Unit
//Hard drive:: lkjldf
//RAM:: Yep I know






Some loose ends
---------------
* `dotted.DottedDict` and `dotted.DottedList` for sparse-testing (nested) structures
* Using BDD
** For unit tests
** Using it only for slow (Selenium) UI tests
* Use 3^rd^ person in your Gherkin
* Use present tense
* _One Scenario_, _One Behaviour_
** No series of steps - checks - steps - checks
* `pytest-bdd` as an alternative




Resources and Links
-------------------

Automation Panda::
    https://automationpanda.com/bdd/
    +
    https://automationpanda.com/2017/01/26/bdd-101-the-gherkin-language/
Wikipedia::
    https://en.wikipedia.org/wiki/Behavior-driven_development
Behave docs::
    https://behave.readthedocs.io/
PyHamcrest docs::
    https://pyhamcrest.readthedocs.io/
`dotted`::
    https://pypi.org/project/dotted/
Cosmic Python::
    https://www.cosmicpython.com/


Recap
-----
You've heard about the following:
[role="incremental"]
* What is Behavior Driven Development
** How it relates to Test Driven Development
** How it relates to Domain Driven Design
* How does the Gherkin language looks like
** Including various constructs within the language
* How to use `behave` as BDD tool for Python
** How to create step definitions (making the specs executable)
** How to run it
** How to select (groups of) tests
** How to use setup- and teardown-fixtures
* How to test different interfaces of your system with the same tests (slow vs fast)
** By using the `--stage` option
* Additional packages to make validating easier
** PyHamcrest for more expressive validation and better diagnostics
** `dotted.DottedDict` and `dotted.DottedList` for complex data validation (needed? desired?)
* Some pieces of advice when specifying Gherkin
** Think twice about using BDD for unit tests
** Think twice about only using BDD for slow (Selenium-based) ui tests
** Don't use Gherkin to do complex technical system setup
** Use 3^rd^ person
** Use present tense
** _one scenario_, _one behavior_
* Alternative(s) for `behave`
* Additional resources

Thank You
---------

Jan-Hein Bührman

FIXME some twitter and email handles here, I guess, perhaps a link to the presentation (QR code?)

Slides created with AsciiDoc using the "slidy" back end (https://asciidoc-py.github.io/slidy.html)

Questions
---------
.Questions
****
❓
****
